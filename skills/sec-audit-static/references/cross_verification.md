# Cross-Verification Procedure

자동 스캐너 결과에 대한 교차검증 절차. 오탐 제거 및 정밀도 향상 목적.

## 적용 시점

- Phase 2 자동 스캔 완료 후 (task 2-2 injection 결과 확정 전)
- 자동 판정 "취약" 건에 대해 전수 교차검증 실시

## 교차검증 5단계

### Step 1: 데이터 흐름 추적 (Source → Sink)

```
Controller (@RequestParam/PathVariable/RequestBody)
    → Service (비즈니스 로직)
        → Repository (데이터 접근)
            → SQL Builder (쿼리 생성 - Kotlin/Java)
                → DB 실행
```

각 단계에서 취약 파라미터의 **값의 출처**를 확인:
- 사용자 입력 (HTTP 요청) → **취약 가능**
- 내부 하드코딩 값 → **정보 (잠재적 위험)**
- DB 조회 결과 → **검토 필요** (2차 인젝션 가능성)
- Spring 설정값 (`@Value`) → **정보 (타입에 따라)**

### Step 2: 타입 안전성 확인

| 타입 | SQL Injection 가능 여부 |
|------|----------------------|
| `String` | 가능 - 문자열 조작 가능 |
| `long`, `int`, `boolean` | 불가 - 숫자/불린만 허용 |
| `enum` | 불가 - 정의된 값만 허용 |
| `List<String>` | 가능 - 개별 요소 확인 필요 |

### Step 3: 코드 활성화 여부

- `/* ... */` 블록 주석으로 감싼 클래스/메서드 → "정보(비활성 코드)"
- `@Deprecated` + 호출부 없음 → "정보(미사용 코드)"
- `@Profile("test")` 등 특정 환경 전용 → 명시

### Step 4: 분기 경로 도달 확인

Service에서 switch/if 분기로 여러 Repository 메서드를 호출하는 경우:
- Controller에서 전달되는 `filter`, `type` 등의 값으로 **어떤 case에 도달하는지** 확인
- 취약 메서드가 포함된 case에 도달하지 않으면 → "정보(경로 미도달, 오탐)"

### Step 5: 최종 판정

| 조건 | 판정 |
|------|------|
| 사용자 입력 String → SQL 직접 삽입 (검증 없음) | **취약** |
| 사용자 입력이지만 화이트리스트/enum 검증 존재 | 양호 |
| 하드코딩 값만 사용 | 정보 (잠재적 위험) |
| long/int 타입 설정값 | 정보 (타입 안전) |
| 주석 처리 비활성 코드 | 정보 (비활성 코드) |
| 코드 경로 미도달 | 정보 (오탐) |

## 결과 업데이트

교차검증 완료 시 JSON 결과에 반영:
```json
{
  "result": "정보",
  "diagnosis_type": "정보: 잠재적 위험 (하드코딩 값만 사용)",
  "diagnosis_detail": "정보(잠재적 위험): ... 상세 사유 ...",
  "diagnosis_method": "교차검증(수동)",
  "needs_review": false
}
```

## 보고서 표기

교차검증으로 재분류된 건은 보고서에 다음과 같이 구분 표기:
- **취약(확인됨)**: 교차검증 통과 - 실제 Exploit 가능
- **정보(잠재적 위험)**: 코드 패턴은 취약하나 현재 Exploit 불가
- **정보(비활성 코드)**: 주석 처리 등으로 실행되지 않는 코드
- **정보(오탐)**: 코드 경로 분석 결과 취약 메서드에 도달 불가
